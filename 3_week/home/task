1.
Встраивать функцию можно с помощью ключевого слова inline. Он как-бы вставляет тело функции в место вызова в основной функции. Это, своего рода, рекомендация компилятору разворачивать функию там.
Следует использовать для маленьких функций, расходов на вызов которых будут больше, чем на её "вставку" на указанное место. 
При больших функциях не надо, ибо компиляторможет израсходовать больше за счёт копирования и вставки, нежели на вызов. 

// ок

2.
Можно указать все аргументы функции по умолчанию. Если надо указать не все, то "свободные" должны быть первыми,
а в конец перечесления аргументов вставить аргументы со значением по умолчанию. Нельзя, чтоб были пропуски (поочерёдно - нельзя).
Да:  f(int x, int y, int z = 8, int b = 4);
Нет: f(int x = 3, int y, int z = 8, int b);

//ок

3.
На основании аргументов, что указаны при вызове функции. Если вызов f(5), то начнёт работать функция f(int x), а не f(double x) и f(int x, int y). 

//ок

4.
Объявление функции: RT <name> (T1, T2); // имя и тип
Определение функции: RT <name> (T1, T2){ ...} // всё вместе
Писать лучше короткие функции, большие разбивать на мелкие.
Передачв аргументов в функции происходит по значению, ссылке или по адресу. 

Лямбда выражения - анонимная функция 
[..область захвата..](..аргументы функции..){..тело лямбды ..}
Захват внешней переменной (состояние):  [=],[&],[x, y],[&x, &y],[=, &x, &y],[]
Захват обычной функции - через static. Тип функции RT(AL)

//ты все-таки не поняла вопрос. Сохранить состояние имеется ввиду сохранить состояние переменной. Првильный ответ: для функций - использовать static переменные, а для лямбд - выполнить захват по ссылке.

5.
Макросы сложно отлаживать, они имеют "побочные эффекты" при разворачивании - потребуется писать очень аккуратный код со скобками /но и это не всегда помагает/.
Они не имеют пространства имён - название макроса нельзя будет применять для чего-то другого /также названия глобальные/, ещё для них существенно играет роль проблема выбора имени. 

//ок
